#!/hive/sbin/bash


#
# Copyright (C) 2016-2020  Hiveon
# Distributed under GNU GENERAL PUBLIC LICENSE 2.0
# License information can be found in the LICENSE file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE.txt
#
# Linted by shellcheck 0.3.7
#


readonly script_mission='Client for ASICs: Messenger'
readonly script_version='0.2.9'
readonly script_basename="$( basename "$0" )"


# vars

declare HIVE_API_endpoint this_argument
declare message_type message_header message_color
declare id id_json payload payload_json
declare request response
declare file_to_send file_size


# sources

source colors


# main

# you could use externally defined RIG_CONF
[[ -z "$RIG_CONF" ]] && RIG_CONF='/hive-config/rig.conf'

if [[ ! -s "$RIG_CONF" ]]; then
	echo "${script_basename}> Config file $RIG_CONF empty or not found"
	exit 1
fi

source "$RIG_CONF"

HIVE_API_endpoint="${HIVE_HOST_URL%/}/worker/api" # cut the trailing slash in HIVE_HOST_URL, if any (like as in rocketchain's local API server URL)

message_type="$1"
message_header="$2"

if [[ -z "$message_type" || -z "$message_header" ]]; then
	echo -e "Usage: ${CYAN}$script_basename success|danger|warning|info|tag \"message\" [payload] [-i|--id=msgid]${NOCOLOR}"
	echo -e "       ${CYAN}$script_basename file /path/name"
	echo
	echo 'Aliases: ok|error|err|warn|default'
	echo 'Attention: payload is read from stdin'
	echo
	exit 1
fi

case "$message_type" in
	'error'|'err')
		message_type='danger'
		message_color="$RED"
	;;

	'warning'|'warn')
		message_type='warning'
		message_color="$YELLOW"
	;;

	'ok'|'success')
		message_type='success'
		message_color="$GREEN"
	;;

	'tag')
		message_color="$PURPLE"
	;;

	'file')
		file_to_send="$message_header"
		message_header="$( basename "$file_to_send" )"
		# if file isn't empty or it's a named pipe (for <() constructions)
		if [[ -s "$file_to_send" || -p "$file_to_send" ]]; then
			: ok good to go
		else
			echo "${script_basename}> File not found or empty: $file_to_send"
			exit 1
		fi
	;;

	*)
		message_color="$CYAN"
	;;
esac

# shellcheck disable=SC2016
request="$(
	jq \
		--null-input \
		--arg rig_id "$RIG_ID" \
		--arg passwd "$RIG_PASSWD" \
		--arg type "$message_type" \
		--arg data "$message_header" \
		'{
			"method": "message", "jsonrpc": "2.0", "id": 0,
			"params": {$rig_id, $passwd, $type, $data}
		}'
)"

for this_argument in "${@:3}"; do
	case "$this_argument" in
		'-i='*|'--id='*)
			id="${this_argument#*=}"
			# shellcheck disable=SC2016
			id_json="$( jq --arg id "$id" --null-input '{"params": {$id}}' )"
			request="$( jq --slurp --compact-output '.[0] * .[1]' <<< "$request $id_json" )"
		;;

		'payload'|'--payload')
			payload="$( < /dev/stdin )"
			payload_json="$( jq --raw-input --slurp '{"params": {"payload": .}}' <<< "$payload" )"
			request="$( jq --slurp --compact-output '.[0] * .[1]' <<< "$request $payload_json" )"
		;;

		*)
			echo "ERROR: unknown option '$this_argument'"
		;;
	esac
done

if [[ -n "$file_to_send" ]]; then
	file_size="$( stat -c %s "$file_to_send" 2> /dev/null )"
	payload="$( gzip -c9 < "$file_to_send" | openssl base64 -e -A 2> /dev/null )"
	payload_json="$( jq --raw-input --slurp '{"params": {"payload": .}}' <<< "$payload" )"
	request="$( jq --slurp --compact-output '.[0] * .[1]' <<< "$request $payload_json" )"
fi

if [[ -z "$payload" ]]; then
	echo -en "${script_basename}> Sending '$message_type' message: ${message_color}$message_header${NOCOLOR}... "
elif [[ -n "$file_to_send" ]]; then
	echo -en "${script_basename}> Sending file $file_to_send ($file_size bytes compressed to ${#payload})... "
else
	echo -en "${script_basename}> Sending '$message_type' message with payload (${#payload} bytes): ${message_color}$message_header${NOCOLOR}... "
fi

response="$(
	curl \
		--insecure --location --data @- --connect-timeout 15 --max-time 25 --silent \
		-XPOST "${HIVE_API_endpoint}?id_rig=${RIG_ID}&method=message" \
		--header 'Content-Type: application/json' \
	<<< "$request"
)"

exitcode=$?
if (( exitcode )); then
	echo "${BRED}NETWORK ERROR${NOCOLOR}"
	echo "${script_basename}> Cannot send message (curl code=$exitcode)"
	exit $(( exitcode ))
fi

error="$( jq '.error' --raw-output <<< "$response" )"
if [[ -n "$error" && "$error" != "null" ]]; then
	echo "${BRED}API SERVER ERROR${NOCOLOR}"
	echo "${script_basename}> Server response: $error"
	exit 1
fi

echo "${BGREEN}OK${NOCOLOR}"

exit 0
