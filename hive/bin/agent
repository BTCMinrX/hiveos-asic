#!/hive/sbin/bash


#
# Copyright (C) 2016-2020  Hiveon
# Distributed under GNU GENERAL PUBLIC LICENSE 2.0
# License information can be found in the LICENSE file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE.txt
#


readonly script_mission='Client for ASICs: The Agent'
readonly script_version='0.4.5'
readonly script_basename="$( basename "$0" )"
#
readonly script_DEBUG="${script_DEBUG:-0}" # use value from env if exists


# !!! bash strict mode, no unbound variables
#set -o nounset # disabled bc it hasn't been tested thoroughly


# functions

function debug_print_variable {
	#
	# Usage: debug_print_variable 'variable_name'...
	#

	# consts
	local -r debug_prefix='|'

	# vars
	local this_var this_var_name this_var_status JSON_array_size variable_color
	local -i max_length=0 this_var_size total_vars_count total_vars_size

	# code
	for this_var in "$@"; do
		(( ${#this_var} > max_length )) && max_length="${#this_var}"
	done

	printf "${DGRAY}%s %-${max_length}.${max_length}s %8.8s %4.4s  %s %s${NOCOLOR}\n" "$debug_prefix" 'var' 'bytes' 'idx' 'value'

	for this_var_name in $( printf '%s\n' "$@" | sort ); do
		JSON_array_size=''
		variable_color="${NOCOLOR}"
		this_var_size=0
		local -n this_var_value="$this_var_name"

		if [[ ! "${this_var_value+is_set}" ]]; then
			this_var_status='unset'
		elif [[ -z "${this_var_value}" ]]; then
			this_var_status='empty'
		else
			this_var_size="${#this_var_value}"
			this_var_status="${this_var_size}"
			if JSON_array_size="$( jq --raw-output 'if type=="array" then . | length else "" end' <<< "$this_var_value" 2> /dev/null )"; then
				variable_color="${GREEN}"
			fi
		fi

		printf "${DGRAY}%s ${variable_color}%-${max_length}.${max_length}s ${CYAN}%8.8s %4.4s  ${DGRAY}'${NOCOLOR}%s${DGRAY}' ${DGRAY}%s${NOCOLOR}\n" "$debug_prefix" "$this_var_name" "$this_var_status" "$JSON_array_size" "$this_var_value"

		(( total_vars_size += this_var_size,
		total_vars_count++ ))
	done

	if (( total_vars_count > 1 )); then
		printf "${DGRAY}%s %u var(s), %u bytes${NOCOLOR}\n" "$debug_prefix" $(( total_vars_count )) $(( total_vars_size ))
	fi
} 1>&2

function sanitize_vars_for_argjson {
	#
	# Usage: sanitize_vars_for_argjson 'variable_name'...
	#

	# consts
	local -r JSON_safe_stub='null'

	# vars
	local this_var_ref this_var

	# code
	for this_var_ref in "$@"; do
		local -n this_var="$this_var_ref"
		if [[ -z "$this_var" ]]; then
			#errcho "\$$this_var_ref is empty"
			this_var="$JSON_safe_stub"
		elif ! jq --compact-output '.' <<< "$this_var" > /dev/null 2>&1; then
			errcho "\$$this_var_ref is not a valid JSON: '$this_var'"
			this_var="$JSON_safe_stub"
		fi
	done
}

function is_screen_session_running {
	#
	# Usage: is_screen_session_running 'screen_session_name'
	#

	# args
	local -r screen_session_name="${1-}"

	# code
	# shellcheck disable=SC2154
	# bc exitcode_ERROR_SOMETHING_WEIRD declared in library
	[[ -z "$screen_session_name" ]] && return $(( exitcode_ERROR_SOMETHING_WEIRD )) ### TODO rework
	screen -S "$screen_session_name" -X . > /dev/null
}

function screen_session_terminate {
	#
	# Usage: screen_session_terminate 'screen_session_name'
	#

	# args
	local -r screen_session_name="${1-}"

	# code
	[[ -z "$screen_session_name" ]] && return $(( exitcode_ERROR_SOMETHING_WEIRD )) ### TODO rework
	screen -S "$screen_session_name" -X quit > /dev/null
}

function milliseconds_to_seconds {
	#
	# Usage: milliseconds_to_seconds 'milliseconds'
	#

	# args

	local -r -i milliseconds="${1-}"

	# vars

	local -i s_part ms_part
	local sign

	# code

	if (( milliseconds < 0 )); then
		milliseconds=0-milliseconds
		sign='-'
	else
		sign=''
	fi

	(( s_part = milliseconds / 1000,
	ms_part = milliseconds % 1000 / 10 )) # let's leave only 2 digits after the dot bc we don't have such a precision

	printf '%s%u.%u\n' "$sign" "$s_part" "$ms_part"
}

function get_time_difference_in_s {
	#
	# Usage: get_time_difference_in_s 'start_time_in_ms'
	#

	# args

	local -r -i start_time_in_ms="${1-}"

	# vars

	local -i finish_time_in_ms wasted_time_in_ms
	local time_difference_in_s

	# code
	finish_time_in_ms="$( get_system_uptime_in_milliseconds )"
	(( wasted_time_in_ms = finish_time_in_ms - start_time_in_ms ))
	time_difference_in_s="$( milliseconds_to_seconds $(( wasted_time_in_ms )) )"

	echo "$time_difference_in_s"
}

function reduce_hashrate_to_khs {
	#
	# Usage: reduce_hashrate_to_khs 'input_hashrate_value' 'hs|khs|mhs|ghs|ths|phs' 'output_hashrate_in_khs_by_ref'
	#

	# args
	local -r input_hashrate_value="${1-0}"
	local -r input_hashrate_unit="${2-khs}" # khs is the Hive default
	local -r -n output_hashrate_in_khs_by_ref="${3-}"

	# consts
	local -r -A relationship_to_khs_DICT=(
		['phs']='1000000000000'
		['ths']='1000000000'
		['ghs']='1000000'
		['mhs']='1000'
		['khs']='1'
		['hs']='0.001'
	)

	# vars
	local input_hashrate_unit_SAFE relationship_to_khs

	# code

	# first sanitize input_hashrate_unit
	: "${input_hashrate_unit,,}" # tolower()
	: "${input_hashrate_unit//\/}" # strip an eventual '/'

	input_hashrate_unit_SAFE="$_"
	if [[ "$input_hashrate_unit_SAFE" == 'khs' ]]; then # don't have to calculate anything
		output_hashrate_in_khs_by_ref="$input_hashrate_value"
		# shellcheck disable=SC2154
		# bc exitcode_OK declared in library
		return $(( exitcode_OK ))
	fi

	relationship_to_khs="${relationship_to_khs_DICT[$input_hashrate_unit_SAFE]-}"
	if [[ -z "$relationship_to_khs" ]]; then
			errcho "Hashrate unit not in dictionary: '$input_hashrate_unit'"
			# shellcheck disable=SC2154
			# bc exitcode_ERROR_NOT_FOUND declared in library
			return $(( exitcode_ERROR_NOT_FOUND ))
	fi

	if [[ "${input_hashrate_value}${relationship_to_khs}" == *[0-9].[0-9]* ]]; then
		# it's FP and we need awk then
		# shellcheck disable=SC2034
		output_hashrate_in_khs_by_ref="$(
			awk -v input_hashrate_value="$input_hashrate_value" \
				-v relationship_to_khs="$relationship_to_khs" \
				'BEGIN{ print input_hashrate_value * relationship_to_khs }'
		)"
	else
		# all integer
		(( output_hashrate_in_khs_by_ref = input_hashrate_value * relationship_to_khs ))
	fi
}

function send_request_to_miner_api {
	#
	# Usage: send_request_to_miner_api 'request_body'
	#

	# args

	local -r request_body="${1-}"

	# consts

	local -r -i timeout=7

	# code

	case "$ASIC_MODEL" in
		'Zig Z1+'|'Zig Z1')
			timeout "$timeout" nc "$miner_API_host" "$miner_API_port" <<< "$request_body" 2> /dev/null
		;;

		*)
			timeout -t "$timeout" nc "$miner_API_host" "$miner_API_port" <<< "$request_body" 2> /dev/null
		;;
	esac | tr -d '\0\n' # sanitize

	return "${PIPESTATUS[0]}"
}

function get_stats_raw {
	#
	# Usage: get_stats_raw
	#

	send_request_to_miner_api '{"command":"stats"}'
}

function get_pools_raw {
	#
	# Usage: get_pools_raw
	#

	send_request_to_miner_api '{"command":"pools"}'
}

function process_pools {
	#
	# !!! may change var from global scope: system_status
	# !!! may change vars from outer scope: POOLS active_pool_id
	#

	# consts
	local -r active_pool_id_RE='^[0-9]+$'

	# vars
	local pools_raw

	# code
	if pools_raw="$( get_pools_raw )"; then
		if POOLS="$( jq --compact-output '.POOLS' <<< "$pools_raw" )"; then
			if active_pool_id="$( jq --raw-output '[. as $object | keys[] | select($object[.]."Stratum Active" == true and $object[.]."Priority" <= 3) as $pool | select($object[$pool]."Getworks")] | .[0]' <<< "$POOLS" 2> /dev/null )"; then
				if [[ "$active_pool_id" =~ $active_pool_id_RE ]]; then
					: ok good to go
				else
					log_line error 'All user pools are not alive:'
					jq --color-output --compact-output \
						'.[] |
							select( .Priority <= 3 ) |
								with_entries(
									select(
										.key |
											test( "Stratum Active", "URL", "User", "Status", "Priority" )
									)
								)' \
						<<< "$POOLS"
					echo
					case "$system_status" in
						'mining' | 'tuning' | 'NA' )
							system_status='deadpool'
						;;
					esac
					return $(( exitcode_ERROR_NOT_FOUND ))
				fi
			else
				log_line warning "No active pools yet"
				return $(( exitcode_ERROR_NOT_FOUND ))
			fi
		else
			log_line warning "No pools yet"
		fi
	else
		log_line warning "Failed to read pool stats from $miner_API_host:$miner_API_port"
	fi
}

function get_miner_stats {
	#
	# Usage: get_miner_stats 'miner_name'
	#

	# args
	local miner_name="$1"

	# vars
	local stats_raw max_fan_rpm STATS
	local algo hs_units uptime hashrate_raw hashrate_raw_avg
	local POOLS active_pool_id
	local hs temp chip_temp board_temp fan fan_rpm freq freq_new acn status chain_voltage hw_errors power asicboost ar

	# arrays
	local -a error_vars=() # must be empty

	# traps
	function sanitize_khs {
		[[ -z "$khs"	]] && khs=0
		[[ -z "$khs_av"	]] && khs_av=0
	}
	trap 'sanitize_khs' RETURN

	# code
	khs=0				# global
	khs_av=0			# global
	stats=''			# global

	algo="$ASIC_ALGO"
	hs_units="$HASH"
	# shellcheck disable=SC2153
	# ...bc MAX_FAN_RPM var is from asic-model
	max_fan_rpm="$MAX_FAN_RPM"

	case "$ASIC_MODEL" in
		'Antminer '						|\
		'Antminer E3'					|\
		'Antminer S9'|'Antminer S9i'|'Antminer S9j'|'Antminer S9 Hydro'|'Antminer S9 (vnish'*|'Antminer S9'*|'Minecenter S9'|\
		'Antminer S10'*					|\
		'Antminer S11'					|\
		'Antminer S15'					|\
		'Antminer S17'*					|\
		'Antminer T9+'*|'Antminer T9'*	|\
		'Antminer T15'					|\
		'Antminer T17'*					|\
		'Antminer X17'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n' | sed 's/}{/},{/' | jq '.'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				system_status="$( ant-functions hiveon_status 'ERR_NO_STATS' )" # check for 'tuning' state
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" )" # fix broken API (like S9): '}{' -> '},{'

				hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				reduce_hashrate_to_khs "$hashrate_raw" "$HASH" khs
				hashrate_raw_avg="$( jq --raw-output '.[1]."GHS av"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				reduce_hashrate_to_khs "$hashrate_raw_avg" "$HASH" khs_av

				system_status="$( ant-functions hiveon_status "$STATS" )"

				process_pools || return

				uptime="$(			jq --raw-output		'.[1].Elapsed'																																<<< "$STATS" )"
				hs="$(				jq --compact-output	'.[1] | with_entries( select(.key | test("chain_rate\\d+")) )		| to_entries | [ .[].value | if . != "" then tonumber else "" end  ]'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "hs#$?" )
				temp="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("temp2_\\d+")) )			| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "temp#$?" )
				chip_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp_chip\\d+")))			| to_entries | [ .[].value | split("-") | max | tonumber ]'				<<< "$STATS" 2> /dev/null )" || error_vars+=( "chip_temp#$?" )
				board_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp\\d+$")) )			| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "board_temp#$?" )
				fan="$(				jq --compact-output --argjson max_fan_rpm "$max_fan_rpm" \
														'.[1] | with_entries( select(.key | test("fan\\d+")) )				| to_entries | [ .[].value / $max_fan_rpm * 100 + 0.5 | floor ]'		<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan#$?" )
				fan_rpm="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("fan\\d+")) )				| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_rpm#$?" )
				freq="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("freq_avg\\d+")) )			| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq#$?" )
				freq_new="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("freq\\d+")) )				| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq_new#$?" )
				acn="$(				jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acn\\d+")) )		| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "acn#$?" )
				status="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )		| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "status#$?" )
				chain_voltage="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("chain_voltage\\d+")) )	| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_voltage#$?" )
				hw_errors="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_hw\\d+")) )			| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "hw_errors#$?" )
#				power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )		| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
				power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )		| to_entries | from_entries'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
				asicboost="$(		jq					'.[1] | with_entries( select(.key | test("chain_power$")) )			| to_entries | .[].value | test("AB") | if . == true then 1 else 0 end'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "asicboost#$?" )
				ar="$(				jq --compact-output --argjson pool "$active_pool_id" \
														'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'				<<< "$POOLS" 2> /dev/null )" || error_vars+=( "ar#$?" )

				[[ "$chain_voltage" == '[]'	]] && chain_voltage="$( ant-functions hiveon_voltage <<< "$acn" )"
				[[ "$power" != '{}'			]] && power="$( ant-functions hiveon_power "$power" "$acn" )"
				[[ "$chip_temp" =~ .[0-9]	]] && temp="$chip_temp"
				[[ "$freq_new" =~ .[0-9]	]] && freq="$freq_new"

				sanitize_vars_for_argjson 'hs' 'temp' 'board_temp' 'fan' 'fan_rpm' 'freq' 'chain_voltage' 'acn' 'power' 'hw_errors' 'status' 'uptime' 'ar' 'asicboost'
				stats="$( jq --null-input --compact-output \
					--arg		'algo'			"$algo"					--argjson	'hs'		"$hs" \
					--arg		'hs_units'		"$hs_units"				--argjson	'temp'		"$temp" \
					--argjson	'board_temp'	"$board_temp"			--argjson	'fan'		"$fan" \
					--argjson	'fan_rpm'		"$fan_rpm"				--argjson	'freq'		"$freq" \
					--argjson	'chain_voltage'	"$chain_voltage"		--argjson	'acn'		"$acn" \
					--argjson	'power'			"$power"				--argjson	'hw_errors'	"$hw_errors" \
					--argjson	'status'		"$status"				--argjson	'uptime'	"$uptime" \
					--argjson	'ar'			"$ar"					--argjson	'asicboost'	"$asicboost" \
					\
					'{$algo, $hs, $hs_units, $temp, $board_temp, $fan, $fan_rpm, $freq, $chain_voltage, $acn,
					$power, $hw_errors, $status, $uptime, $ar, $asicboost}' \
					\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats algo hs hs_units temp chip_temp board_temp fan fan_rpm freq freq_new chain_voltage acn power hw_errors status uptime ar asicboost
			fi
		;;

		'Antminer A3'										|\
		'Antminer D3'|'Antminer D3 Blissz'*|'Antminer DR3'	|\
		'Antminer L3+'*|'Antminer L3++'						|\
		'Antminer S7'										|\
		'Antminer X3'										|\
		'Antminer Z9'*										|\
		'Antminer Z11'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				system_status="$( ant-functions hiveon_status 'ERR_NO_STATS' )" # check for 'tuning' state
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" )" # fix broken API: '}{' -> '},{'

				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				reduce_hashrate_to_khs "$hashrate_raw" "$HASH" khs
				hashrate_raw_avg="$( jq --raw-output '.[1]."GHS av"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				reduce_hashrate_to_khs "$hashrate_raw_avg" "$HASH" khs_av

				system_status="$( ant-functions hiveon_status "$STATS" )"

				process_pools || return

				uptime="$(		jq --raw-output		'.[1].Elapsed'																															<<< "$STATS" )"
				hs="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_rate\\d+")) )	| to_entries | [ .[].value | if . != "" then tonumber else "" end  ]'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "hs#$?" )
				temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp2_\\d+")) )		| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "temp#$?" )
				board_temp="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "board_temp#$?" )
				fan="$(			jq --compact-output --argjson max_fan_rpm "$max_fan_rpm" \
													'.[1] | with_entries( select(.key | test("fan\\d+")) )			| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'			<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan#$?" )
				fan_rpm="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("fan\\d+")) )			| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_rpm#$?" )
				freq="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("frequency\\d+")) )	| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq#$?" )
				acn="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acn\\d+")) )	| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "acn#$?" )
				power="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )	| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
				status="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "status#$?" )
				hw_errors="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("chain_hw\\d+")) )		| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "hw_errors#$?" )
				ar="$(			jq --compact-output --argjson pool "$active_pool_id" \
													'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'			<<< "$POOLS" 2> /dev/null )" || error_vars+=( "ar#$?" )

				chain_voltage="$( ant-functions hiveon_voltage <<< "$acn" )"
				miner_count="$( jq '. | length' <<< "$acn" )"
				if [[ "$( jq --raw-output length <<< "$freq" )" -ne "$miner_count" ]]; then
					freq_new='[]'
					freq="$( jq						'.[1] | with_entries( select(.key | test("frequency")) )		| to_entries | [.[].value]'												<<< "$STATS" )" || error_vars+=( "freq#$?" )
					freq_num="$( jq --raw-output '.[0]' <<< "$freq" )" || error_vars+=( "freq_num#$?" )
					for (( c=1; c<=miner_count; c++ )); do
						freq_new="$( jq --raw-output --arg freq_num "$freq_num" '[.[], $freq_num | tonumber]' <<< "$freq_new" )" || error_vars+=( "freq_new#$?" )
					done
				else
					freq_new="$freq"
				fi

				sanitize_vars_for_argjson 'hs' 'temp' 'board_temp' 'fan' 'fan_rpm' 'freq_new' 'chain_voltage' 'acn' 'power' 'hw_errors' 'status' 'uptime' 'ar'
				stats="$( jq --null-input --compact-output \
					--arg		'algo'			"$algo"					--argjson	'hs'		"$hs" \
					--arg		'hs_units'		"$hs_units"				--argjson	'temp'		"$temp" \
					--argjson	'board_temp'	"$board_temp"			--argjson	'fan'		"$fan" \
					--argjson	'fan_rpm'		"$fan_rpm"				--argjson	'freq'		"$freq_new" \
					--argjson	'chain_voltage'	"$chain_voltage"		--argjson	'acn'		"$acn" \
					--argjson	'power'			"$power"				--argjson	'hw_errors'	"$hw_errors" \
					--argjson	'status'		"$status"				--argjson	'uptime'	"$uptime" \
					--argjson	'ar'			"$ar" \
					\
					'{$algo, $hs, $hs_units, $temp, $board_temp, $fan, $fan_rpm, $freq, $chain_voltage, $acn,
					$power, $hw_errors, $status, $uptime, $ar}' \
					\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats algo hs hs_units temp chip_temp board_temp fan fan_rpm freq freq_new chain_voltage acn power hw_errors status uptime ar asicboost
			fi
		;;

		'Zig Z1+'	|\
		'Zig Z1')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "$stats_raw" )"

				hashrate_raw="$( jq --raw-output '.[0]."MHS 30S"' <<< "$STATS" )"
				reduce_hashrate_to_khs "$hashrate_raw" "$HASH" khs

				uptime="$(		jq --raw-output		'.[0].Elapsed'																																												<<< "$STATS" )"
				hs="$(			jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | ."MHS 30S"]'															<<< "$STATS" )" || error_vars+=( "hs#$?" )
				temp="$(		jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | ."Temperature"]'														<<< "$STATS" )" || error_vars+=( "temp#$?" )
				fan="$(			jq --compact-output --argjson max_fan_rpm "$max_fan_rpm" \
													'.[0]						| with_entries( select(.key | test("Fan In|Fan Out") ) )	| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'										<<< "$STATS" )" || error_vars+=( "fan#$?" )
				fan_rpm="$(		jq --compact-output	'.[0]						| with_entries( select(.key | test("Fan In|Fan Out") ) )	| to_entries | [.[].value ]'																		<<< "$STATS" )" || error_vars+=( "fan_rpm#$?" )
				freq="$(		jq --compact-output	'.[0].Frequency as $freq	| .[0] | with_entries( select(.key | test("CH\\d+") ) )		| to_entries | [.[].value | $freq ]'																<<< "$STATS" )" || error_vars+=( "freq#$?" )
				acn="$(			jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | .status | length ]'														<<< "$STATS" )" || error_vars+=( "acn#$?" )
				status="$(		jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | .status | [.[].accept | if . > 0 then "o" else "x" end ] | join("") ]'	<<< "$STATS" )" || error_vars+=( "status#$?" )
#				hw_errors="$(	jq --compact-output	'.[1]						| with_entries( select(.key | test("chain_hw\\d+")) )		| to_entries | [.[].value]'																			<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )

				sanitize_vars_for_argjson 'hs' 'temp' 'fan' 'fan_rpm' 'freq' 'acn' 'status' 'uptime'
				stats="$( jq --null-input --compact-output \
					--arg		'algo'			"$algo"					--argjson	'hs'		"$hs" \
					--arg		'hs_units'		"$hs_units"				--argjson	'temp'		"$temp" \
					--argjson	'fan'			"$fan"					--argjson	'fan_rpm'	"$fan_rpm" \
					--argjson	'freq'			"$freq"					--argjson	'acn'		"$acn" \
					--argjson	'status'		"$status"				--argjson	'uptime'	"$uptime" \
					\
					'{$algo, $hs, $hs_units, $temp, $fan, $fan_rpm, $freq, $acn, $status, $uptime}' \
					\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats algo hs hs_units temp chip_temp board_temp fan fan_rpm freq freq_new chain_voltage acn power hw_errors status uptime ar asicboost
			fi
		;;

		'b29+.g19'						|\
		'd9.g19'						|\
		's11.g19'						|\
		't2t.soc'|'t2t+.soc'			|\
		't2th.soc'|'t2th+.soc'|'t2thf.soc'|'t2thf+.soc'|'t2thl+.soc'|'t2thm.soc'|\
		't2ti.soc'						|\
		't2ts.soc'						|\
		't2tz.soc'						|\
		't1.g19'						|\
		't3.soc'|'t3+.soc'|'t3h+.soc')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				#stats_raw="$( sed 's/}{/\},{/' <<< "$stats_raw" )"
				STATS="$( jq --compact-output '.STATS' <<< "$stats_raw" )"

				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				hashrate_raw="$( jq --raw-output '.[-1] | .[] | add' < /tmp/stats.json )"
				reduce_hashrate_to_khs "$hashrate_raw" "$HASH" khs

				uptime="$(		jq --raw-output		'.[0].Elapsed'																											<<< "$STATS"		)"
				hs="$(			jq --raw-output		'[.[-1] | .[] | .[]]'																									< /tmp/stats.json	)" || error_vars+=( "hs#$?" )
				temp="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("^Temp$")) )			| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "temp#$?" )
				fan="$(			jq --compact-output	'[.[] | with_entries( select(.key | test("^Fan duty$")) )		| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "fan#$?" )
				freq="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("^PLL")) )				| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "freq#$?" )
				acn="$(			jq --compact-output	'[.[] | with_entries( select(.key | test("Num chips")) )		| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "acn#$?" )
				status="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("Num active chips")) )	| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "status#$?" )
				hw_errors="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("HW errors")) )		| to_entries | [.[].value] | add | select(.!=null)]'	<<< "$STATS"		)" || error_vars+=( "hw_errors#$?" )

				sanitize_vars_for_argjson 'hs' 'temp' 'fan' 'freq' 'acn' 'hw_errors' 'status' 'uptime'
				stats="$( jq --null-input --compact-output \
					--arg		'algo'			"$algo"					--argjson	'hs'		"$hs" \
					--arg		'hs_units'		"$hs_units"				--argjson	'temp'		"$temp" \
					--argjson	'fan'			"$fan"					--argjson	'freq'		"$freq" \
					--argjson	'acn'			"$acn"					--argjson	'hw_errors'	"$hw_errors" \
					--argjson	'status'		"$status"				--argjson	'uptime'	"$uptime" \
					\
					'{$algo, $hs, $hs_units, $temp, $fan, $freq, $acn, $hw_errors, $status, $uptime}' \
					\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats algo hs hs_units temp chip_temp board_temp fan fan_rpm freq freq_new chain_voltage acn power hw_errors status uptime ar asicboost
			fi
		;;

		'T4.G19')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( send_request_to_miner_api '{"command":"devs"}' )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.DEVS' <<< "$stats_raw" )"

				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				hashrate_raw="$( jq --raw-output '[.[]["MHS av"]] | add' <<< "$STATS" )"
				reduce_hashrate_to_khs "$hashrate_raw" "$HASH" khs

				uptime="$(		jq --raw-output		'.[0]["Device Elapsed"]'																	<<< "$STATS" )"
				hs="$(			jq --compact-output	'[.[] | with_entries( select(.key | test("MHS 5s")) )			| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "hs#$?" )
				temp="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("TempAVG")) )			| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "temp#$?" )
				freq="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("CORE")) )				| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "freq#$?" )
				acn="$(			jq --compact-output	'[.[] | with_entries( select(.key | test("DUTY")) )				| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "acn#$?" )
#				status="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("Num active chips")) )	| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "status#$?" )
				hw_errors="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Hardware Errors")) )	| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )

				sanitize_vars_for_argjson 'hs' 'temp' 'freq' 'acn' 'hw_errors' 'uptime'
				stats="$( jq --null-input --compact-output \
					--arg		'algo'			"$algo"					--argjson	'hs'		"$hs" \
					--arg		'hs_units'		"$hs_units"				--argjson	'temp'		"$temp" \
					--argjson	'freq'			"$freq"					--argjson	'acn'		"$acn" \
					--argjson	'hw_errors'		"$hw_errors"			--argjson	'uptime'	"$uptime" \
					\
					'{$algo, $hs, $hs_units, $temp, $freq, $acn, $hw_errors, $uptime}' \
					\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats algo hs hs_units temp chip_temp board_temp fan fan_rpm freq freq_new chain_voltage acn power hw_errors status uptime ar asicboost
			fi
		;;

		'Toddminer C1'*)
			stats="$( todd_api stats )"
			hashrate_raw="$( jq '.hs | add' <<< "$stats" )"
			reduce_hashrate_to_khs "$hashrate_raw" "$HASH" khs
			# shellcheck disable=SC2071
			# bc of float comparison
			[[ "$khs" > '0' ]] && system_status='mining'
			(( script_DEBUG )) && debug_print_variable stats
		;;

		'Blackminer F1'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" )" # fix broken API: '}{' -> '},{'

				local COIN="$( jq --raw-output '."coin-type"' < /config/cgminer.conf )"
				POWER=(50)
				[[ -e /hive/share/blackminer/blackminer.json ]] && BBDATA="$( jq --exit-status '.' < /hive/share/blackminer/blackminer.json )"
				if (( $? == 0 )); then
					ASIC_ALGO="$( jq --raw-output --arg coin "$COIN" '.[$coin].algo' <<< "$BBDATA" )" || error_vars+=( "ASIC_ALGO#$?" )
					POWER="$( jq --raw-output --arg coin "$COIN" '.[$coin].power' <<< "$BBDATA" )" || error_vars+=( "POWER#$?" )
				fi

				##echo $ASIC_ALGO $POWER
				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				algo="$ASIC_ALGO"
				hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				reduce_hashrate_to_khs "$hashrate_raw" "$HASH" khs

				process_pools || return

				uptime="$(		jq --raw-output		'.[1].Elapsed'																													<<< "$STATS" )"
				hs="$(			jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_rate\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "hs#$?" )
#				temp="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("temp2_\\d+")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "temp#$?" )
				temp="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "temp#$?" )
				board_temp="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "board_temp#$?" )
				fan="$(			jq --compact-output --argjson max_fan_rpm "$max_fan_rpm" \
													'.[1]	| with_entries( select(.key | test("fan\\d+")) )		| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'	<<< "$STATS" )" || error_vars+=( "fan#$?" )
				fan_rpm="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("fan\\d+")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "fan_rpm#$?" )
				freq="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("frequency\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "freq#$?" )
				miner_count="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("miner_count")) )	| to_entries | .[].value'										<<< "$STATS" )" || error_vars+=( "miner_count#$?" )
				acn="$(			jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_acn\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "acn#$?" )
				status="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "status#$?" )
				hw_errors="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_hw\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )
				ar="$(			jq --compact-output --argjson pool "$active_pool_id" \
									'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'	<<< "$POOLS" )" || error_vars+=( "ar#$?" )

				if [[ "$( jq --raw-output length <<< "$freq" )" -ne "$miner_count" ]]; then
					freq_new='[]'
					freq="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("frequency")) )		| to_entries | [.[].value]'										<<< "$STATS" )"
					freq_num="$( jq --raw-output '.[0]' <<< "$freq" )"
					for (( c=1; c<=miner_count; c++ )); do
						freq_new="$( jq --raw-output --arg freq_num "$freq_num" '[.[], $freq_num | tonumber]' <<< "$freq_new" )"
					done
				else
					freq_new="$freq"
				fi

				power="$( jq --slurp --compact-output '.' <<< "$POWER" )"

				sanitize_vars_for_argjson 'hs' 'temp' 'board_temp' 'fan' 'fan_rpm' 'freq_new' 'acn' 'power' 'ar' 'hw_errors' 'status' 'uptime'
				stats="$( jq --null-input --compact-output \
					--arg		'algo'			"$algo"					--argjson	'hs'		"$hs" \
					--arg		'hs_units'		"$hs_units"				--argjson	'temp'		"$temp" \
					--argjson	'board_temp'	"$board_temp"			--argjson	'fan'		"$fan" \
					--argjson	'fan_rpm'		"$fan_rpm"				--argjson	'freq'		"$freq_new" \
					--argjson	'acn'			"$acn"					--argjson	'power'		"$power" \
					--argjson	'ar'			"$ar"					--argjson	'hw_errors'	"$hw_errors" \
					--argjson	'status'		"$status"				--argjson	'uptime'	"$uptime" \
					\
					'{$algo, $hs, $hs_units, $temp, $board_temp, $fan, $fan_rpm, $freq, $acn, $power, $ar,
					$hw_errors, $status, $uptime}' \
					\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats algo hs hs_units temp chip_temp board_temp fan fan_rpm freq freq_new chain_voltage acn power hw_errors status uptime ar asicboost
			fi
		;;

		*)
			errcho "Unsupported ASIC model '$ASIC_MODEL'"
			MINER='unknown'
		;;
	esac

	# show vars with errors, if any
	(( ${#error_vars[@]} )) && log_line debug "Missing keys: ${error_vars[*]}"
}

function get_loadavg_as_json {
	# vars
	local -a loadavg_array
	local IFS

	# code
	loadavg_array=( $( < /proc/loadavg ) ) # /proc/loadavg: '1.24 1.25 1.34 3/251 5135'
	IFS=','
	echo "[${loadavg_array[*]::3}]"
}

function get_diskfree {
	df -h "/${MOUNT}" | awk '{ print $4 }' | tail -n 1 | sed 's/%//'
}

function get_saved_last_cmd_id {
	# vars
	local saved_last_cmd_id

	# code
	if [[ -s "$last_cmd_id_FILE" ]]; then
		saved_last_cmd_id="$( < "$last_cmd_id_FILE" )"
		(( script_DEBUG )) && log_line debug "[DEBUG] $last_cmd_id_FILE content is $saved_last_cmd_id" 1>&2 # TODO modify library to bear this redirection
	else
		saved_last_cmd_id=''
	fi

	(( script_DEBUG )) && log_line debug "[DEBUG] saved_last_cmd_id is '$saved_last_cmd_id'" 1>&2
	echo "$saved_last_cmd_id"
}

function process_khs_and_arr {
	# compute, display and write out 'arr' (Accepted/Rejected Ratio) and 'khs' for watchdog

	# vars
	local -i khs_decimal
	local arr_rounded_to_2 arr_to_display

	# code

	# arr section
	if is_JSON_string_not_empty_or_null "$stats"; then
		arr_rounded_to_2="$(
			jq 'def roundit: . * 100.0 + 0.5 | floor / 100.0;
				try (
					.ar | . as [$accepted,$rejected,$incorrect] | add |
					if . > 10 then
						$accepted / . * 100 | roundit
					else
						null
					end
				)
				catch null
			' <<< "$stats"
		)"
	fi

	if is_JSON_string_not_empty_or_null "$arr_rounded_to_2"; then
		arr_to_display=" (${arr_rounded_to_2}% accepted)"
		printf '%.0f\n' "$arr_rounded_to_2" > "$arr_FILE"
	else
		arr_to_display=''
		printf 'null\n' > "$arr_FILE"
	fi
	(( script_DEBUG )) && debug_print_variable 'arr_rounded_to_2'

	# khs section
	khs_decimal="$( scientific_to_decimal "$khs" )"
	if (( khs_decimal > 0 )); then
		log_line info "$MINER hashrate ${WHITE}$( khs_to_human_friendly_hashrate "$khs" )${NOCOLOR}$arr_to_display, stats collected in ${WHITE}${time_wasted_collecting_stats_in_s}s"
	else
		log_line warning "$MINER hashrate ${WHITE}0 H/s${NOCOLOR}$arr_to_display, stats collected in ${WHITE}${time_wasted_collecting_stats_in_s}s"
	fi

	# write khs to file for watchdog
	echo "$khs" > "$khs_FILE"
}

function loop {
	# vars
	local -i curl_exitcode
	local -i time_start_collecting_stats time_start_sending_stats
	local time_wasted_collecting_stats_in_s time_wasted_sending_stats_in_s
	local PUSH_INTERVAL custom_interval_message
	local cpuavg df last_cmd_id

	# code
	if ! which 'jq' > /dev/null; then
		# TODO we could assemble a simple request even without jq, but does it worth it?
		# !!! DONE
		log_line error 'jq not found'
	fi

	if [[ ! -f "$RIG_CONF" ]]; then
		log_line error "Config file $RIG_CONF not found, waiting..."
		return
	fi

	if [[ ! -f "$WALLET_CONF" ]]; then
		log_line error "Wallet file $WALLET_CONF not found"
	fi

	# each time read config again
	source "$RIG_CONF"
	source "$WALLET_CONF"

	# if rig config contains PUSH_INTERVAL then change default to custom
	if [[ -n "${PUSH_INTERVAL-}" ]] && (( PUSH_INTERVAL != push_interval_DEFAULT )); then
		INTERVAL="$PUSH_INTERVAL"
		custom_interval_message="${LGRAY}[push interval ${INTERVAL}s]${NOCOLOR} "
	else
		INTERVAL="$push_interval_DEFAULT"
		custom_interval_message=''
	fi

	[[ -n "$TIMEZONE" ]] && export TZ="$TIMEZONE"
	[[ -z "$MINER" ]] && MINER='asicminer'

	log_line info "${custom_interval_message}Collecting stats from ${WHITE}${MINER}${NOCOLOR} API..."

	time_start_collecting_stats="$( get_system_uptime_in_milliseconds )"
	get_miner_stats "$MINER"
	time_wasted_collecting_stats_in_s="$( get_time_difference_in_s $(( time_start_collecting_stats )) )"

	process_khs_and_arr

	cpuavg="$( get_loadavg_as_json )"
	df="$( get_diskfree )"
	last_cmd_id="$( get_saved_last_cmd_id )"

	# construct a request
	sanitize_vars_for_argjson 'RIG_ID' 'last_cmd_id' 'META' 'stats' 'khs' 'khs_av' 'cpuavg'
	request="$(
		jq --null-input --compact-output \
			--argjson	rig_id			"$RIG_ID" \
			--arg		passwd			"$RIG_PASSWD" \
			--argjson	last_cmd_id		"$last_cmd_id" \
			--arg		miner			"$MINER" \
			--argjson	meta			"$META" \
			--argjson	miner_stats		"$stats" \
			--argjson	total_khs		"$khs" \
			--argjson	avg_khs			"$khs_av" \
			--arg		system_status	"$system_status" \
			--arg		df				"$df" \
			--argjson	cpuavg			"$cpuavg" \
			\
			'def walk(f):
				. as $in
				| if type == "object" then
					reduce keys_unsorted[] as $key
					( {}; . + { ($key):  ($in[$key] | walk(f)) } ) | f
				elif type == "array" then map( walk(f) ) | f
				else f
				end;
			{
				"method": "stats", "jsonrpc": "2.0", "id": 0,
				"params": {
					$rig_id, $passwd, $last_cmd_id,
					$miner, $meta,
					$miner_stats, $total_khs, $avg_khs,
					$system_status, $df, $cpuavg
				}
			} | walk(
					if type == "object" then
						with_entries(select( .value != null and .value != {} and .value != [] ))
					elif type == "array" then
						map(select( . != null and . != {} and .!= [] ))
					else
						.
					end
				)' # remove: 1. empty objects; 2. empty arrays; 3. keys with null value
	)"

	# fall-back route (like in case of a broken jq or some)
	if [[ $? -ne 0 || -z "$request" ]]; then
		log_line error 'Something went wrong while constructing a JSON request. Fall back to a safe mode...'
		debug_print_variable 'RIG_ID' 'last_cmd_id' 'META' 'stats' 'khs' 'khs_av' 'cpuavg'
		# good ol' bash string assembly
		request="{\"method\":\"stats\",\"jsonrpc\":\"2.0\",\"id\":0,\"params\":{\"rig_id\":${RIG_ID},\"passwd\":\"${RIG_PASSWD}\",\"miner\":\"$MINER\",\"system_status\":\"$system_status\"}}"
	fi

	# show the request, password cloaked
	jq '.params.passwd=$cloaked_pass' --arg cloaked_pass "${RIG_PASSWD//?/*}" --compact-output <<< "$request"

	if [[ -z "$RIG_ID" ]]; then
		log_line warning "No RIG_ID, skipping sending stats"
		return
	fi

	HIVE_URL="$HIVE_HOST_URL"
	HIVE_URL_collection[0]="$HIVE_URL" # 0th index is for an original HIVE_HOST_URL
	HIVE_URL_collection[1]="$HIVE_URL" # 1st index is for an original HIVE_HOST_URL, second connection attempt

	# !!! and now the duct tape
	# protection measures -- we don't have https on the vast majority of ASICs
	if [[ "$HIVE_URL" == 'https://'* ]]; then
		log_line warning "API Server $HIVE_URL is not supported, most likely"
		HIVE_URL_collection[1]="${HIVE_URL/https:\/\//http:\/\/}" # and 2nd place for an http form of https'ed HIVE_HOST_URL
		if (( https_disabled_message_sent == 0 )); then
			cp "$RIG_CONF" "${RIG_CONF}.original"
			sed -i 's|HIVE_HOST_URL="https://|HIVE_HOST_URL="http://|' "$RIG_CONF"
			message warning "Server URL with HTTPS might not be supported on this ASIC. It's recommended to switch to HTTP (Settings->Mirror select)" --silent
			mv "${RIG_CONF}.original" "$RIG_CONF"
			https_disabled_message_sent=1
		fi
	fi

	local -i curl_connect_timeout=1 curl_max_time=2 # very short timeouts for the first attempt, we don't want the agent to be a slowpoke
	local -i attempts_counter=1
	for this_URL in "${HIVE_URL_collection[@]}"; do
		if (( attempts_counter == 1 )); then
			log_line info "Sending stats (${#request} bytes) to ${this_URL}..."
		else
			log_line warning "Re-sending stats (${#request} bytes) to ${this_URL} (attempt #$attempts_counter)..."
		fi
		time_start_sending_stats="$( get_system_uptime_in_milliseconds )"
		response="$(
			curl \
				--verbose --trace-time --insecure --location --data @- \
				--connect-timeout "$curl_connect_timeout" --max-time "$curl_max_time" \
				--silent --fail \
				--request POST "${this_URL}/worker/api?id_rig=$RIG_ID&method=stats" \
				--header 'Content-Type: application/json' \
				\
			<<< "$request" \
			2> "$latest_curl_log"
		)"
		curl_exitcode=$?
		time_wasted_sending_stats_in_s="$( get_time_difference_in_s $(( time_start_sending_stats )) )"

		if (( curl_exitcode )); then
			log_line error "Error sending stats with exitcode $curl_exitcode in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}. Connection log:"
			# shellcheck disable=SC2005
			echo "$( < "$latest_curl_log" )"
			# bc it's a pure bash cat emulation
			echo
		else
			break
		fi

		(( curl_connect_timeout = 15, curl_max_time = 25 )) # much longer timeouts for all next attempts
		(( attempts_counter++ ))
	done

	if [[ $curl_exitcode -ne 0 || -z "$response" ]]; then
		log_line error "No attempts left. Let's refresh the IP cache..."
		/hive/bin/timeout -t 10 /hive/bin/cache-hive-ip
		return "$curl_exitcode"
	fi


	# errors processing
	local error
	#
	error="$( jq --raw-output '.error' <<< "$response" )"
	if (( $? )); then
		log_line error "Invalid response received in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}:\n$response"
		return 1
	fi

	if is_JSON_string_not_empty_or_null "$error"; then
		log_line error "Error response received in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}: $error"
		return 1
	fi


	# command processing
	local command
	#
	command="$( jq --raw-output '.result.command' <<< "$response" )"
	if [[ $command == 'OK' ]]; then
		if [[ -f "$last_cmd_id_FILE" ]]; then
			(( script_DEBUG )) && log_line debug "[DEBUG] removing $last_cmd_id_FILE"
			rm "$last_cmd_id_FILE"
		fi
	else
		local response_stripped="${response//\\n/\\\\n}" # neuter the \n's
		log_line info "Server answer: $( jq --compact-output --color-output '.result' <<< "$response_stripped" )"
		skip_the_sleep=1
	fi


	# confseq processing
	local confseq_received confseq_saved
	#
	confseq_received="$( jq --raw-output '.result.confseq' <<< "$response" )"
	if is_JSON_string_not_empty_or_null "$confseq_received"; then
		if [[ -s "$confseq_FILE" ]]; then
			confseq_saved="$( < "$confseq_FILE" )"
		else
			# first time run, just save current confseq
			confseq_saved="$confseq_received"
			echo "$confseq_received" > "$confseq_FILE"
		fi

		if (( confseq_saved != confseq_received )); then
			# save updated confseq
			echo "$confseq_received" > "$confseq_FILE"
			case "$command" in
				'config' | 'wallet' | 'asic_oc' | 'asic' )
					log_line debug "[DEBUG] config command received. Config sequence updated: $confseq_saved -> $confseq_received"
				;;
				*)
					log_line debug "[DEBUG] no config command received, but config sequence updated: $confseq_saved -> $confseq_received. Let's say hello again..." # (and then get an updated config)
					hello # TODO fork to bg?
				;;
			esac
		fi
	else
		(( script_DEBUG )) && log_line debug "[DEBUG] server answer lacks 'confseq' key, confseq processing skipped"
	fi


	# to batch or not to batch
	local body
	local -i commands_count this_command_index
	#
	if [[ "$command" != 'batch' ]]; then
		body="$( jq --compact-output '.result' <<< "$response" )"
		do_command
	else
		commands_count="$( jq '.result.commands | length' <<< "$response" )"
		log_line info "Got $commands_count batch commands"
		for (( this_command_index = 0; this_command_index < commands_count; this_command_index++ )); do
			body="$( jq --compact-output --argjson index "$this_command_index" '.result.commands[$index]' <<< "$response" )"
			command="$( jq --raw-output '.command' <<< "$body" )" # get command for batch
			do_command
		done
	fi
}

function backslash {
	local var="${1//\\/\\\\}"
	var="${var//\"/\\\"}"
	var="${var//\`/\\\`}"
	var="${var//\$/\\\$}"
	echo "$var"
}

function do_command {
	# consts
	local -r command_log="/tmp/${script_basename}-${command// /-}.log"

	# vars
	local cmd_id version exec shutdown_fuse_file exectimeout asic_oc firmware_url
	local config justwrite line NEW_PASSWD request response error wallet
	local -i curl_exitcode exec_exitcode time_limit
	#local TMUX	# let's test it later

	# code
#	[[ -z "$command" ]] && command="$( jq --raw-output '.command' <<< "$body" )" #get command for batch

	# cmd_id processing (optional command identifier)
	cmd_id="$( jq --raw-output '.id' <<< "$body" )"
	[[ "$cmd_id" == 'null' ]] && cmd_id=''
	# save last cmd_id
	(( script_DEBUG )) && log_line debug "[DEBUG] incoming cmd_id is '$cmd_id'"
	if (( cmd_id > 0 )); then
		(( script_DEBUG )) && log_line debug "[DEBUG] saving cmd_id '$cmd_id' to $last_cmd_id_FILE"
		echo "$cmd_id" > "$last_cmd_id_FILE"
	fi

	log_line ok "'$command' received in ${WHITE}${time_wasted_sending_stats_in_s}s"

	case "$command" in
		'OK')
			# do nothing
			:
		;;

		'reboot')
			message ok 'Rebooting' --id="$cmd_id" --silent
			log_line ok 'Rebooting'
			#nohup bash -c 'sreboot' > "$command_log" 2>&1 &
			/sbin/reboot
		;;

		'upgrade')
			version="$( jq --raw-output '.version' <<< "$body" )"
			[[ "$version" == 'null' ]] && version=
			screen -dm -S selfupgrade bash -c '
				selfupgrade '"$version"' 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Client update successful" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Client update failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'upgrade beta')
			screen -dm -S selfupgrade bash -c '
				selfupgrade master 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Client update successful" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Client update failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'exec')
			exec="$( jq --raw-output '.exec' <<< "$body" )"

			case "$exec" in
				'hssh start')
					unset TMUX # !!! duct tape
				;;

				'sreboot shutdown')
					shutdown_fuse_file="/tmp/${script_basename}-shutdown-fuse.lock"
					if [[ ! -f "$shutdown_fuse_file" ]]; then
						message warning 'Vast majority of ASICs does not support shutdown. Click for details' --payload --id="$cmd_id" --silent <<-EOF
							<h3>Vast majority of ASICs does not support shutdown</h3>It might be the ASIC will simply go offline. You will more than likely have to power it off manually.
							If you know what are you doing, please <strong>send this command one more time</strong>
							EOF
						touch "$shutdown_fuse_file"
						return
					else
						rm "$shutdown_fuse_file"
						message ok 'ASIC powered off' --id="$cmd_id" --silent
						snore 5 # wait 5s until the message has been sent
					fi
				;;
			esac

			# !!! a secret spell: if the command to exec prefixed with ':;', then no time limit enabled
			if [[ "${exec:0:2}" == ':;' ]]; then
				exectimeout='nohup bash -c' # no time limit at all
			else
				(( time_limit = 60 * 60 * 3 )) # 3 hrs tops
				# shellcheck disable=SC2076
				if [[ $ASIC_MODEL == 'Zig Z1' || $ASIC_MODEL == 'Zig Z1+' || $ASIC_MODEL =~ 'Toddminer C1' ]]; then
					# use Debian /usr/bin/timeout
					exectimeout="nohup timeout $time_limit bash -c"
				else
					# use a BusyBox one
					exectimeout="nohup timeout -t $time_limit bash -c"
				fi
			fi

			#
			# do we need an intermediate file? here's a file-less approach with pipe:
			#
			#$exectimeout '
			#	( '"$exec"' ) 2>&1 | if (( $? == 0 )); then
			#		message info "'"$( backslash "$exec" )"'" --payload --id='"$cmd_id"'
			#	else
			#		message error "'"$( backslash "$exec" )"' (failed, exitcode=$?)" --payload --id='"$cmd_id"'
			#	fi
			#' > "$command_log" 2>&1 &

			local agent_exec_log="/tmp/agent-exec-$cmd_id.log"
			#local exec_backslashed="$( backslash "$exec" )" # don't need it anymore

			$exectimeout '# {agent-exec}
				( '"$exec"' ) > "$1" 2>&1
				exec_exitcode=$?
				if (( exec_exitcode == 0 )); then
					message info "$0" --payload --id="$2" --silent < "$1"
				else
					message error "$0 (failed, exitcode=$exec_exitcode)" --payload --id="$2" --silent < "$1"
				fi
				rm "$1" > /dev/null 2>&1
			' "$exec" "$agent_exec_log" "$cmd_id" > "$command_log" 2>&1 & disown
		;;

		'asic_oc')
			if is_screen_session_running "$command"; then
				screen_session_terminate "$command"
				log_line warning "Command '$command' already running. Terminated."
				snore 1
			fi
			export asic_oc="$( jq --raw-output '.asic_oc' <<< "$body" )"
			[[ -f /config/use-new-asic-oc ]] && mv /config/use-new-asic-oc /hive-config/use-new-asic-oc # adjusting legacy location to an actual one
			# !!!                      a secret feature vvvvvvvvvvvvvvvvvvvvvvvvvvvv
			if (( HIVEON_VERSION_major >= 2 )) || [[ -f /hive-config/use-new-asic-oc ]]; then
				asic_oc_cmd='asic-oc'
			else
				asic_oc_cmd='asic_oc'
			fi
			screen -dm -S "$command" bash -c '
				echo "Auto-tune parameters:"
				echo
				jq "." <<< "$asic_oc"
				echo
				'"$asic_oc_cmd"' "$asic_oc" 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Auto-tune is finished. Click for details" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Auto-tune error. Click for details" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'firmware-upgrade')
			if is_screen_session_running "$command"; then
				log_line warning "Command '$command' already running. Execution skipped."
				message warning "Firmware upgrade skipped. Click for details" --payload --id="$cmd_id" --silent <<< "Previous firmware upgrade process is still running. Please wait for it to finish and then send the command again."
				return
			fi
			export firmware_url="$( jq --raw-output '.firmware_url' <<< "$body" )"
			screen -dm -S "$command" bash -c '
				firmware-upgrade "$firmware_url" 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Firmware upgrade successful, rebooting..." --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Firmware upgrade failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'config')
			config="$( jq --raw-output '.config' <<< "$body" )"
			justwrite="$( jq --raw-output '.justwrite' <<< "$body" )" #don't restart miner, just write config, maybe WD settings will be updated
			if is_JSON_string_not_empty_or_null "$config"; then
				#scan for password change
				while read -r line; do
					if [[ "$line" =~ ^RIG_PASSWD=\"(.*)\" ]]; then
						NEW_PASSWD="${BASH_REMATCH[1]}"
						break
					fi
				done <<< "$config"

				# Password change ---------------------------------------------------
				if [[ "$RIG_PASSWD" != "$NEW_PASSWD" ]]; then
					log_line warning "Old password: $RIG_PASSWD, new password: $NEW_PASSWD"

					message warning 'New password received, please wait for the green message...' --id="$cmd_id" --silent
					request="$( jq --null-input --compact-output \
						--arg rig_id "$RIG_ID" --arg passwd "$RIG_PASSWD" \
						'{ "method": "password_change_received", "params": {$rig_id, $passwd}, "jsonrpc": "2.0", "id": 0}'
					)"
					response="$(
						curl --insecure --location --data @- --connect-timeout 15 --max-time 25 --silent \
						--request POST "${HIVE_URL}/worker/api?id_rig=$RIG_ID&method=password_change_received" \
						--header "Content-Type: application/json" \
						<<< "$request"
					)"

					curl_exitcode=$?
					if (( curl_exitcode != 0 )); then
						message error 'Error notifying hive about "password_change_received"' --id="$cmd_id" --silent
						return "$curl_exitcode" #better exit because password will not be changed
					fi

					error="$( jq --raw-output '.error' <<< "$response" )"
					if is_JSON_string_not_empty_or_null "$error"; then
						log_line error "Server error: $( jq --raw-output '.error.message' <<< "$response" )"
						return 1
					fi

					jq '.' <<< "$response"
					#after this there will be new password on server, so all new request should use new one
				fi

				# Write new config and load it ---------------------------------------
				echo "$config" > "$RIG_CONF" && sync
				source "$RIG_CONF"

				# Save wallet if given -----------------------------------------------
				wallet="$( jq --raw-output '.wallet' <<< "$body" )"
				is_JSON_string_not_empty_or_null "$wallet" && echo "$wallet" > "$WALLET_CONF"

				# Overclocking if given in config --------------------------------------
#				oc_if_changed

				# Final actions ---------------------------------------------------------
				if [[ "$justwrite" != 1 ]]; then
					#hostname-check
					/hive/bin/miner restart
					echo
				fi

				# Start Watchdog. It will exit if WD_ENABLED=0 ---------------------------
				if (( "${WD_ENABLED:-0}" )); then
					nohup wd stop > /dev/null 2>&1
					snore 5
				fi
				wd start &

				message ok 'Rig config changed' --id="$cmd_id" --silent
				#[[ $? -eq 0 ]] && message ok 'Wallet changed, miner restarted' --id=$cmd_id || message warn "Error restarting miner" --id=$cmd_id
				sync
			else
				message error 'No rig "config" given' --id="$cmd_id" --silent
			fi
		;;

		'wallet')
			wallet="$( jq --raw-output '.wallet' <<< "$body" )"
			if is_JSON_string_not_empty_or_null "$wallet"; then
				echo "$wallet" > "$WALLET_CONF" && sync

				justwrite=
#				oc_if_changed

				/hive/bin/miner restart
				if (( $? == 0 )); then
					message ok 'Wallet changed, miner restarted' --id="$cmd_id" --silent
				else
					message warn 'Error restarting miner' --id="$cmd_id" --silent
				fi
			else
				message error 'No "wallet" config given' --id="$cmd_id" --silent
			fi
		;;

		'asic')
			hiveon_config="$( jq --raw-output '.asic' <<< "$body" )"
			if is_JSON_string_not_empty_or_null "$hiveon_config"; then
				grep -v '^_' <<< "$hiveon_config" > "$HIVEON_CONF"
				grep -v '^_' <<< "$hiveon_config" > "$ASIC_CONF"
				grep '^_' <<< "$hiveon_config" > "$HIVEON_CONF_VOLT"
				sync
				/hive/bin/miner restart
				if (( $? == 0 )); then
					message ok 'ASIC config changed, miner restarted' --id="$cmd_id" --silent
				else
					message warn 'Error restarting miner' --id="$cmd_id" --silent
				fi
			else
				message error 'No "asic" config given' --id="$cmd_id" --silent
			fi
		;;


		*)
			log_line error "Unknown command received: '$command'"
		;;

	esac
}

function sleep_with_progress_bar {
	#
	# print a shrinking progress bar while sleeping
	#
	# Usage: sleep_with_progress_bar 'seconds_to_sleep'
	#

	# args
	local -r -i seconds_to_sleep="$1"

	# vars
	local -i this_step
	local seconds_remaining_as_spaces seconds_remaining_as_dots

	# code

	for (( this_step = 0; this_step < seconds_to_sleep; this_step++ )); do
		printf -v seconds_remaining_as_spaces '%*s' $(( seconds_to_sleep - this_step ))
		seconds_remaining_as_dots="${seconds_remaining_as_spaces// /.}"
		printf '\r%b%s%b%*s\r' "${DGRAY}" "$seconds_remaining_as_dots" "${NOCOLOR}" "$this_step"
		snore 1
	done
	printf '\r%*s\n' "$seconds_to_sleep" # clear the line and then \n
}


# consts

# paths to conf files
declare -r RIG_CONF='/hive-config/rig.conf'
declare -r WALLET_CONF='/hive-config/wallet.conf'
declare -r HIVEON_CONF='/hive-config/hiveon.conf'
declare -r HIVEON_CONF_VOLT='/hive-config/hiveon.conf'
declare -r ASIC_CONF='/config/config.conf'
# path to runtime vars
declare -r khs_FILE='/run/hive/khs'
declare -r arr_FILE='/run/hive/arr' # Accepted/Rejected ratio * 100
declare -r last_cmd_id_FILE='/run/hive/last_cmd_id'
declare -r confseq_FILE='/run/hive/confseq'

declare -r latest_curl_log="/tmp/${script_basename}-curl.log"
declare -r miner_API_host='localhost'
declare -r -i miner_API_port=4028
declare -r -i push_interval_DEFAULT=10

# vars

declare MINER='asicminer'
declare khs khs_av system_status stats
declare -i INTERVAL=push_interval_DEFAULT https_disabled_message_sent=0
declare -i time_wasted_general time_remaining_general skip_the_sleep
declare -a HIVE_URL_collection=( # indices 0 and 1 are reserved for HIVE_HOST_URL from RIG_CONF
	[2]='http://api.hiveos.farm'
	[3]='http://paris.hiveos.farm'
	[4]='http://amster.hiveos.farm'
	[5]='http://helsinki.hiveos.farm'
	[6]='http://msk.hiveos.farm'
	[7]='http://ca1.hiveos.farm'
)


# sources

[[ -t 1 ]] && source colors
source asic-model
source /hive/bin/hive-functions.sh || { echo 'ERROR: /hive/bin/hive-functions.sh not found'; exit 1; }


# main

#$PPID - might be parent screen pid
screen_count="$( screen -ls | grep "\.agent" | grep -Fcv "$PPID" )"

#there will be still 1 process for subshell
#[[ `ps aux | grep "./agent" | grep -vE "grep|screen|SCREEN|$$" | wc -l` -gt 1 ]] &&
if (( screen_count > 0 )); then
	echo -e "${RED}Agent screen is already running${NOCOLOR}"
	echo -e "Run ${CYAN}agent-screen${NOCOLOR} to resume screen"
	exit 1
fi

log_line ok "$script_mission, version $script_version started"
log_line info "Detected ASIC model: ${WHITE}$ASIC_MODEL"
	echo

# (re)starting wd

if (( "${WD_ENABLED:-0}" )); then
	nohup wd stop > /dev/null 2>&1
	snore 5
fi
wd start &

# main loop

while true; do
	SECONDS=0
	skip_the_sleep=0

	loop

	if (( skip_the_sleep )); then
		# no interval to make the agent more responsive and instantly push last_cmd_id to the server
		echo
		(( script_DEBUG )) && log_line warning '[DEBUG] skip the nap to improve responsiveness after receiving a command'
	else
		(( time_wasted_general = SECONDS ))
		(( time_remaining_general = INTERVAL - time_wasted_general ))

		if (( time_remaining_general > 0 )); then
			sleep_with_progress_bar "$INTERVAL"
		else
			echo
			log_line warning "Stats sending interval ${time_wasted_general}s >= ${INTERVAL}s, overtime is ${time_remaining_general/-}s"
		fi
	fi
done
