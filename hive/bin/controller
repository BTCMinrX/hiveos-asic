#!/hive/sbin/bash
#!/usr/bin/env bash


#
# Copyright (C) 2016-2020  Hiveon
# Distributed under GNU GENERAL PUBLIC LICENSE 2.0
# License information can be found in the LICENSE file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE
#


readonly script_mission='Client for ASICs: Routine controller'
readonly script_version='2.1.3'
readonly script_basename="$( basename "$0" )"
readonly script_debug=0


# !!! bash strict mode, no unbound variables

set -o nounset


# functions

function print_script_usage {																		(( script_debug )) && debugcho

	# code

	echo -e "Usage: ${CYAN-}${script_basename} [log]${NOCOLOR-}"
	echo
	echo -e "       ${WHITE-}log${NOCOLOR-} - show last $log_lines_to_tail lines from log and exit"
	echo
}

function parse_arguments {																			(( script_debug )) && debugcho "$@"

	# args

	local -r argument="${1-}"

	# code

	case "$argument" in
		'log')
			print_script_version
			print_last_lines_from_own_log
			# shellcheck disable=SC2154
			exit $(( exitcode_OK ))
			;;
		'')
			: 'do nothing special'
			;;
		'-h' | '--help')
			print_script_version
			print_script_usage
			# shellcheck disable=SC2154
			exit $(( exitcode_OK ))
			;;
		*)
			print_script_version
			print_script_usage
			# shellcheck disable=SC2154
			exit $(( exitcode_ERROR_IN_ARGUMENTS ))
			;;
	esac
}

function initialize_dictionaries {																	(( script_debug )) && debugcho

	# local consts

	# assembling regexes for various date formats
	# named as strftime() conversion specifier characters
	local -r Y='[12][0-9]{3}' m='[01][0-9]' d='[0123][0-9]' e='[ 123][0-9]' # %e: space padded month's day
	local -r a='(Mon|Tue|Wed|Thu|Fri|Sat|Sun)' b='(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
	local -r H='[012][0-9]' M='[0-5][0-9]' S='[0-5][0-9]'
	local -r F="$Y-$m-$d" T="$H:$M:$S"
	# shellcheck disable=SC2034
	local -r z='[+-][01][0-9]{3}' # %z: +hhmm numeric time zone (e.g., -0400)
	local -r Z="[A-Z][A-Za-z]*" # %Z: alphabetic time zone abbreviation (e.g., EDT)

	# global const hashtables

	# unsupported formats (yet):
	#
	# ISO_8601	2020-04-03T05:38:26
	# RFC 3339	2020-04-03T05:38:26.123456-0000
	# RFC 2822	Fri, 03 Apr 2020 05:38:26 GMT
	#			Fri, 03 Apr 2020 05:38:26.123456 -0000

	declare -r -A -g date_formats_dictionary=(
		['list_by_incidence']='ISO_8601_old perl syslog BusyBox'

		['ISO_8601_old'.RE]="^$F $T"		# 2020-01-18 05:08:13				(19 chars)
		['ISO_8601_old'.pattern]='F T'

		['perl'.RE]="^$a $b $e $T $Y"		# Sun Jan  6 21:29:57 2020			(24 chars)
		['perl'.pattern]='a b e T Y'

		['syslog'.RE]="^$b $e $T"			# Apr  3 20:44:01					(15 chars)
		['syslog'.pattern]='b e T'

		['BusyBox'.RE]="^$a $b $e $T $Z $Y"	# Fri Apr  3 07:29:28 Europe 2020	(31 char)
		['BusyBox'.pattern]='a b e T Z Y'
	)										# in use in:	split_log_line_to_date_and_message

	declare -r -A -g translate_month_name_to_number_dictionary=(
		['Jan']=1 ['Feb']=2 ['Mar']=3 ['Apr']=4  ['May']=5 ['Jun']=6
		['Jul']=7 ['Aug']=8 ['Sep']=9 ['Oct']=10 ['Nov']=11 ['Dec']=12
		['unknown']=0
	)										# in use in:	split_log_line_to_date_and_message

	# global var hashtables

	declare -A -g logs_counters				# in use in:	get_new_lines_from_log

	declare -A -g checkup_counters			# in use in:	is_checkup_counter_set
											#				get_checkup_counter
											#				set_checkup_counter
											#				increment_checkup_counter
											#				reset_checkup_counter
											#				list_checkup_counters
											#
											#				print_checkup_summary_report

}


#
# all about checkup_counters:
#
# is_checkup_counter_set
# get_checkup_counter
# set_checkup_counter
# increment_checkup_counter
# reset_checkup_counter
# list_checkup_counters
#

function is_checkup_counter_set {																	(( script_debug )) && debugcho "$@"
	#
	# Usage: is_checkup_counter_set 'checkup_name' 'counter_name'
	#

	# args

	(( $# != 2 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r checkup_name="${1-}"
	local -r counter_name="${2-}"

	# vars

	local key

	# code

	key="${checkup_name}${unique_delimiter}${counter_name}"
	[[ -n "${checkup_counters[${key}]-}" ]]
}

function get_checkup_counter {																		(( script_debug )) && debugcho "$@"
	#
	# Usage: get_checkup_counter 'checkup_name' 'counter_name'
	#

	# args

	(( $# != 2 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r checkup_name="${1-}"
	local -r counter_name="${2-}"

	# vars

	local key

	# code

	key="${checkup_name}${unique_delimiter}${counter_name}"
	echo "${checkup_counters[${key}]:=0}" # take care of unbound var, hadn't figured out a pretty way
}

function set_checkup_counter {																		(( script_debug )) && debugcho "$@"
	#
	# Usage: set_checkup_counter 'checkup_name' 'counter_name' ['value_to_set'(DEFAULT=1)]
	#

	# args

	(( $# < 2 || $# > 3 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r checkup_name="${1-}"
	local -r counter_name="${2-}"
	local -r -i value_to_set_DEFAULT=1
	local -r value_to_set="${3-${value_to_set_DEFAULT}}"

	# vars

	local key

	# code

	key="${checkup_name}${unique_delimiter}${counter_name}"
	checkup_counters["${key}"]="$value_to_set"
}

function increment_checkup_counter {																(( script_debug )) && debugcho "$@"
	#
	# Usage: increment_checkup_counter 'checkup_name' 'counter_name'
	#

	# args

	(( $# != 2 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r checkup_name="${1-}"
	local -r counter_name="${2-}"

	# vars

	local key

	# code

	key="${checkup_name}${unique_delimiter}${counter_name}"
	: "${checkup_counters[${key}]:=0}" # take care of unbound var, hadn't figured out a pretty way
	# shellcheck disable=SC2149
	(( checkup_counters["${key}"]++ ))
}

function reset_checkup_counter {																	(( script_debug )) && debugcho "$@"
	#
	# Usage: reset_checkup_counter 'checkup_name' 'counter_name'
	#

	# args

	(( $# != 2 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r checkup_name="${1-}"
	local -r counter_name="${2-}"

	# vars

	local key

	# code

	key="${checkup_name}${unique_delimiter}${counter_name}"
	: "${checkup_counters[${key}]:=0}" # take care of unbound var, hadn't figured out a pretty way
	# shellcheck disable=SC2149
	(( checkup_counters["${key}"]=0 ))
}

function list_checkup_counters {																	(( script_debug )) && debugcho
	#
	# Usage: list_checkup_counters
	#
	# print list of all checkups whose counters are set
	# list is unique by design
	#

	# vars

	local -A checkups_list=()
	local this_checkup_counter this_checkup_name

	# code

	# get unique keys to hashtable
	for this_checkup_counter in "${!checkup_counters[@]}"; do
		this_checkup_name="${this_checkup_counter%%${unique_delimiter}*}" # cut all after delimiter (and delimiter too), leave only chekup name
		checkups_list["$this_checkup_name"]='' # ...or any char you want, doesn't matter
	done

	# print hashtable keys sorted
	#while read -r this_checkup_name; do
	#	echo "$this_checkup_name"
	#done < <( printf '%s\n' "${!checkups_list[@]}" | sort ) # oh man, why so complex?

	printf '%s\n' "${!checkups_list[@]}" | sort
}


#
# logs processing:
#
# split_log_line_to_date_and_message
# filter_lines_send_messages
# get_new_lines_from_log
# print_last_lines_from_own_log
# print_controller_log_entry
# shrink_system_logs
#

function split_log_line_to_date_and_message {														(( script_debug )) && debugcho "$@"
	#
	# split_log_line_to_date_and_message 'log_line' 'date_var_by_ref' 'message_var_by_ref'
	#

	# args

	# shellcheck disable=SC2154
	(( $# != 3 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r log_line="${1-}"
	local -r -n _log_date_by_ref="${2-}" # get var by ref
	local -r -n _log_message_by_ref="${3-}" # get var by ref

	# vars

	local a b d e m F T Z Y

	# code

	_log_date_by_ref='--empty-timestamp--'
	_log_message_by_ref="${log_line}"

	for this_format in ${date_formats_dictionary['list_by_incidence']}; do
		if [[ "$log_line" =~ ${date_formats_dictionary[${this_format}.RE]} ]]; then
			# shellcheck disable=SC2086
			read -r ${date_formats_dictionary[${this_format}.pattern]} message <<< "$log_line" # split line by pattern
			[[ -z "${F-}" && -z "${d-}" ]] && printf -v d '%02u' "$(( 10#$e ))" # drop any leading zeros before printf %u
			[[ -z "${F-}" && -z "${m-}" ]] && printf -v m '%02u' "${translate_month_name_to_number_dictionary[${b-unknown}]}"
			[[ -z "${F-}" && -z "${Y-}" ]] && printf -v Y '%(%Y)T' -1
			[[ -z "${F-}" ]] && F="$Y-$m-$d"
			# shellcheck disable=SC2034
			printf -v _log_date_by_ref '%-10.10s %-8.8s' "$F" "$T"
			# shellcheck disable=SC2034
			_log_message_by_ref="${message}"
			break
		fi
	done
}

function filter_lines_send_messages {																(( script_debug )) && debugcho
	#
	# get lines from stdin, parse them and send message, if necessary
	#

	# consts

	local -r -i send_messages_enabled=1
	local -r message_body_template='Log:  <strong>%b</strong>\nDate: <strong>%s</strong>\nType: <strong>%s</strong><hr><h3>%b</h3>'

	# vars

	local log_line log_timestamp log_message_combined_with_log_name log_name event_type message_body

	# code

	while read -r log_line; do
		if [[ -z "${log_line-}" ]]; then
			# skip empty log_lines
			continue
		fi

		split_log_line_to_date_and_message "$log_line" 'log_timestamp' 'log_message_combined_with_log_name' # !! last two vars passed by reference, not by value

		if [[ "$log_message_combined_with_log_name" =~ $unique_delimiter ]]; then
			# split log_message_combined_with_log_name to message and logname
			log_message="${log_message_combined_with_log_name%%${unique_delimiter}*}"
			log_name="${log_message_combined_with_log_name##*${unique_delimiter}}"
		else
			log_message="$log_message_combined_with_log_name"
			log_name=''
		fi

		case "$log_name" in
			'/nvdata/miner_status.log'	)

				case "$log_message" in
					'STATUS_'*					)	event_type='skip'		;;
					'ERROR_'*					)	event_type='error'		;;
					'WARN_'*					)	event_type='warning'	;;
					*							)	event_type='warning'	;;
				esac														;;

			'/config/watchdog.log'		)

				case "$log_message" in
					*'domains fixed'*			)	event_type='ok'			;;
					*'Chain '*'found '*			)	event_type='info'		;; # f.e. 'Chain 1: found 1 bad domains'
					*							)	event_type='warning'	;;
				esac
				# cut milliseconds from watchdog messages like 'Total rate is 0 after 1870.000000 seconds, restart'
				log_message="${log_message//\.000000 seconds/ seconds}"		;;

			'/tmp/tune_log.txt'			)

				case "$log_message" in
					'Tune started'*				)	event_type='ok'			;;
					'All is ok'*				)	event_type='ok'			;; # All is ok, tune is done
					'Achieved '*				)	event_type='warning'	;; # Achieved maximum number of restarts
					*							)	event_type='skip'		;;
				esac														;;

			'/tmp/fault.log'			)			event_type='warning'	;;

			*							)			event_type='warning'	;; # do not frighten the user with 'oh no, the error!'
		esac

		if [[ "$event_type" != 'skip' ]]; then
			printf -v message_body '%-19.19s %-13.13s %b: %b' "$log_timestamp" "[LOG_${event_type^^}]" "$log_name" "$log_message"
			echo "$message_body"
			if (( send_messages_enabled )); then
				printf -v message_body "$message_body_template" "$log_name" "$log_timestamp ${TZ-GMT}" "${event_type^^}" "$log_message"
				echo "$message_body" | message "$event_type" "$log_message" payload
			fi
		fi
	done
}

function get_new_lines_from_log {																	(( script_debug )) && debugcho "$@"
	#
	# get_new_lines_from_log 'log_name' ['log_name'...]
	#
	# the function uses *global* hashtable for saving session data between calls
	# WARNING: it does not work in any pipes and subshells like | () $() <()
	#

	# args

	(( $# < 1 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r -a logs_list=( "$@" )

	# vars

	local previous_lines_quantity current_lines_quantity log_to_check log_to_check_sanitized
	local -i previous_log_size=0
	local -i current_log_size=0
	local -i tail_from_line=0
	local -i how_much_new_lines=0
	local -i is_something_found=$(( exitcode_OK_NOTHING_HAPPENED ))

	# code

	for log_to_check in "${logs_list[@]}"; do
		current_lines_quantity=''

		if [[ -f "$log_to_check" ]]; then
			# don't waste resources to count lines on every iteration, check file size first
			current_log_size="$( get_file_size_in_bytes "$log_to_check" )"

			if [[ -z "${logs_counters[${log_to_check}${unique_delimiter}size]-}" ]]; then # first time, init vars
				current_lines_quantity="$( wc -l < "$log_to_check" )"
				previous_log_size="$current_log_size"
			else # not a first time
				previous_log_size="${logs_counters[${log_to_check}${unique_delimiter}size]}"
			fi

			if (( current_log_size != previous_log_size )); then # log file has changed

				if (( current_log_size > previous_log_size )); then # a few lines had added
					previous_lines_quantity="${logs_counters[${log_to_check}${unique_delimiter}lines]}" # get previous lines count
				elif (( current_log_size < previous_log_size )); then # guess that file was truncated
					previous_lines_quantity=0
				fi

				is_something_found=$(( exitcode_WARNING_SOMETHING_HAPPENED ))
				current_lines_quantity="$( wc -l < "$log_to_check" )" # get current lines count
				(( tail_from_line = previous_lines_quantity + 1 ))
				(( how_much_new_lines = current_lines_quantity - previous_lines_quantity ))
				printf -v log_to_check_sanitized '%q' "$log_to_check"

				if (( current_log_size > previous_log_size )); then # a few lines had added
					tail -n "+$tail_from_line" "$log_to_check" | head -n "$how_much_new_lines" 
				elif (( current_log_size < previous_log_size )); then # guess that file was truncated
					tail -n 100 "$log_to_check"
				fi |
					sed 's|$|'"${unique_delimiter}${log_to_check_sanitized}"'|' --
			fi

			# save current values to previous values
			logs_counters["${log_to_check}${unique_delimiter}size"]="$current_log_size"
			if [[ -n "$current_lines_quantity" ]]; then
				logs_counters["${log_to_check}${unique_delimiter}lines"]="$current_lines_quantity"
			fi
		fi
	done

	return $(( is_something_found ))
}

function print_last_lines_from_own_log {															(( script_debug )) && debugcho
	if [[ -s "$controller_log_file" ]]; then
		tail -n "$log_lines_to_tail" "$controller_log_file"
	fi
}

function print_controller_log_entry {																(( script_debug )) && debugcho "$@"
	#
	# print_controller_log_entry 'event_type' 'log_message'
	#

	# args

	(( $# != 2 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local event_type="${1-<undefined>}"
	local log_message="${2-<undefined>}"

	# code

	printf '%(%F %T)T %-13.13s %b\n' -1 "[${event_type^^}]" "$log_message"
}

function shrink_system_logs {																		(( script_debug )) && debugcho

	# consts

	local -r -i log_lines_shrink_limit=1000

	# vars

	local this_file
	local -i current_number_of_lines_in_log

	# code

	for this_file in /var/log/* /tmp/*.log /hive-config/*.log /config/*.log; do
		if [[ -s "$this_file" ]]; then
			current_number_of_lines_in_log="$( wc -l < "$this_file" )"
			if (( current_number_of_lines_in_log > log_lines_shrink_limit )); then
				print_controller_log_entry 'info' "Shrink log $this_file, $current_number_of_lines_in_log to $log_lines_shrink_limit"
				# shellcheck disable=SC2005,SC2094
				echo "$( tail -n "$log_lines_shrink_limit" "$this_file" )" > "$this_file" # !!! there could be a race condition someday
			fi
		fi
	done
}


#
# auxillary
#

function drop_caches {																				(( script_debug )) && debugcho
	# warning: frequent use of this function may increase NAND wear and tear

	# code

	sync && echo 3 > /proc/sys/vm/drop_caches
}

function wipe_memory {																				(( script_debug )) && debugcho

	# code

	drop_caches
	du -h /tmp/* /var/log/ | grep -F 'M' | awk '{print $2}' | tee >( xargs rm )
}


#
# routine functions executed by cron
#
# checkup:is_it_1970_year
# checkup:is_memory_full
# checkup:is_build_updated
# checkup:is_virus_found
# checkup:is_NAND_in_RO_mode
# checkup:are_logs_updated
# execute:cache_hive_ip
# execute:agent_screen_dontattach
# print_checkup_summary_report
#

function checkup:is_it_1970_year {																	(( script_debug )) && debugcho

	# vars

	local -i current_year date_from_server_in_seconds
	local -i is_something_happened=$(( exitcode_OK_NOTHING_HAPPENED ))

	# code

	printf -v current_year '%(%Y)T' -1

	if (( current_year == 1970 )); then
		is_something_happened=$(( exitcode_WARNING_SOMETHING_HAPPENED ))
		if [[ -z ${HIVE_HOST_URL-} ]]; then
			HIVE_HOST_URL='http://api.hiveos.farm'
		fi
		date_from_server_in_seconds="$( curl --head "$HIVE_HOST_URL" 2>&1 | grep -F 'Date:' | cut -d' ' -f3-6 | timetran )"
		print_controller_log_entry 'warning' "System date is 1970. Getting actual date from server: $( date -s "@$date_from_server_in_seconds" )"
	fi

	return $(( is_something_happened ))
}

function checkup:is_memory_full {																	(( script_debug )) && debugcho

	# consts

	local -r -i low_memory_limit=5000 # 5 Mb
	local -r -i top_lines_count=10

	# vars

	local -i is_something_happened=$(( exitcode_OK_NOTHING_HAPPENED ))
	local free_memory print_top a

	# code

	free_memory="$( grep -Fi 'memfree' /proc/meminfo | sed 's/[^0-9]//g' )"

	if (( free_memory < low_memory_limit )); then
		is_something_happened=$(( exitcode_WARNING_SOMETHING_HAPPENED ))
		print_controller_log_entry 'warning' "Memory low: $free_memory Mb"
		print_top="$( top -b -n1 | head -n "$top_lines_count" )"
		echo -e "$print_top" | tee >( message warn "Low memory detected, trying to clean the logs" payload; echo )

		wipe_memory
		shrink_system_logs
	fi

	return $(( is_something_happened ))
}

function checkup:is_build_updated {																	(( script_debug )) && debugcho

	# consts

	local -r actual_VERSION_file='/hive/etc/VERSION'
	local -r actual_build_file='/hive/etc/build'
	local -r saved_build_file='/hive-config/build'

	# vars

	local -i is_something_happened=$(( exitcode_OK_NOTHING_HAPPENED ))
	local actual_VERSION actual_build saved_build
	local message_header actual_Client_version saved_Client_version

	# code

	if ! cmp -s "$actual_build_file" "$saved_build_file"; then # TODO potential bug: if one of the files (or both) doesn't exist
		
		actual_VERSION="$(	cat "$actual_VERSION_file"	2> /dev/null )" || actual_VERSION='?.??'
		actual_build="$(	cat "$actual_build_file"	2> /dev/null )" || actual_build='release'
		saved_build="$(		cat "$saved_build_file"		2> /dev/null )" || saved_build='release'

		actual_Client_version="${actual_VERSION}-${actual_build}"
		saved_Client_version="${actual_VERSION}-${saved_build}"

		message_header="Client updated from $saved_Client_version to $actual_Client_version"
		print_controller_log_entry 'info' "$message_header"
		message ok "$message_header"
		echo

		[[ -e "$actual_build_file" ]] && cp -f "$actual_build_file" "$saved_build_file"
		
		is_something_happened=$(( exitcode_WARNING_SOMETHING_HAPPENED ))
	fi

	return $(( is_something_happened ))
}

function checkup:is_virus_found {																	(( script_debug )) && debugcho

	# consts

	local -r message_header='Virus signature found. Click to see detailed info'

	# vars

	local -i is_something_happened=$(( exitcode_OK_NOTHING_HAPPENED ))
	local -i is_virus_found=0
	local virus_report

	# code

	if ! is_program_in_the_PATH 'virus-check' > /dev/null; then
		print_controller_log_entry 'warning' "'virus-check' program not found"
		# shellcheck disable=SC2154
		return $(( exitcode_ERROR_NOT_FOUND ))
	fi

	virus_report="$( virus-check )"
	is_virus_found=$?

	if (( is_virus_found )); then
		is_something_happened=$(( exitcode_WARNING_SOMETHING_HAPPENED ))
		print_controller_log_entry 'error' "$message_header"
		if ! is_checkup_counter_set "$FUNCNAME" 'message_sent'; then
			echo -e "$virus_report" | tee >( message err "$message_header" payload; echo )
			if (( assign_tag_to_worker )); then
				message tag 'virus found'
				echo
			fi
			set_checkup_counter "$FUNCNAME" 'message_sent' 1
		fi
	fi

	return $(( is_something_happened ))
}

function checkup:is_NAND_in_RO_mode {																(( script_debug )) && debugcho

	# consts

	local -r -a directories_on_NAND=( '/nvdata' '/config' )

	# vars

	local directory_to_check message_header temp_file
	local -i is_something_happened=$(( exitcode_OK_NOTHING_HAPPENED ))

	# code

	for directory_to_check in "${directories_on_NAND[@]}"; do
		if [[ -d "$directory_to_check" ]]; then
			if temp_file="$( mktemp -p "$directory_to_check" 2> /dev/null )"; then
				rm -rf "$temp_file"
			else
				is_something_happened=$(( exitcode_WARNING_SOMETHING_HAPPENED ))
				message_header="$directory_to_check switched to read-only mode, please check"
				print_controller_log_entry 'error' "$message_header"
				if ! is_checkup_counter_set "$FUNCNAME" 'message_sent'; then
					message err "$message_header"
					set_checkup_counter "$FUNCNAME" 'message_sent' 1
				fi
			fi
		fi
	done

	return $(( is_something_happened ))
}

function checkup:are_logs_updated {																	(( script_debug )) && debugcho

	# consts

	local -r -a logs_to_check=( '/nvdata/miner_status.log' '/config/watchdog.log' '/tmp/tune_log.txt' '/tmp/fault.log' )

	# vars

	local -i is_something_happened=$(( exitcode_OK_NOTHING_HAPPENED ))

	# code

	get_new_lines_from_log "${logs_to_check[@]}" > >( filter_lines_send_messages )

	# ??? could that be the exitcode will come from the last command in chain? I think not, there's a simple redirection
	if (( $? != 0 )); then
		is_something_happened=$(( exitcode_WARNING_SOMETHING_HAPPENED ))
	fi

	return $(( is_something_happened ))
}

function execute:cache_hive_ip {																	(( script_debug )) && debugcho

	# code

	/hive/bin/cache-hive-ip > /dev/null
}

function execute:agent_screen_dontattach {															(( script_debug )) && debugcho

	# code

	/hive/bin/agent-screen dontattach
}


function print_checkup_summary_report {																(( script_debug )) && debugcho

	# vars
	
	local -a checkups_list=()
	local this_checkup
	local -i alarm_counter idle_counter total_counter
	local -i number_of_alarmed_checkups=0 total_number_of_checkups=0

	# code

	readarray -t checkups_list < <( list_checkup_counters ) # you know, <<< $() operator is slower than < <()

	# get number_of_alarmed_checkups
	for this_checkup in "${checkups_list[@]}"; do
		alarm_counter="$( get_checkup_counter "$this_checkup" 'alarm' )"
		if (( alarm_counter != 0 )); then
			(( number_of_alarmed_checkups++ ))
		fi
	done

	total_number_of_checkups="${#checkups_list[@]}"

	if (( number_of_alarmed_checkups == 0 )); then
		print_controller_log_entry 'info' 'Controller daily report: everything was OK over the past 24h'
	else
		print_controller_log_entry 'info' "Controller daily report, $number_of_alarmed_checkups/$total_number_of_checkups checkups involved:"

		#printf '%33.33s %-35.35s %7.7s %7.7s\n' '' 'Checkup' 'Alarms' 'Total'
		for this_checkup in "${checkups_list[@]}"; do
			alarm_counter="$( get_checkup_counter "$this_checkup" 'alarm' )"
			if (( alarm_counter != 0 )); then
				idle_counter="$( get_checkup_counter "$this_checkup" 'idle' )"
				(( total_counter = alarm_counter + idle_counter ))
				printf '%33.33s %-35.35s %u/%u events\n' '' "$this_checkup" "$alarm_counter" "$total_counter"
			fi
			reset_checkup_counter "${this_checkup}" 'alarm'
			reset_checkup_counter "${this_checkup}" 'idle'
		done
	fi
}


#
# cron
#
# populate_array_with_actual_cron_jobs
# wait_for_next_minute
# do_cron_jobs_indefinitely
#

function populate_array_with_actual_cron_jobs {														(( script_debug )) && debugcho "$@"
	#
	# Usage: populate_array_with_actual_cron_jobs 'crontab_array_name' 'jobs_to_do_array'
	#
	# Get crontab array, put command(s) to run atm to jobs_to_do_array
	#
	# crontab array example:
	#
	#		 +------------- minute (0 - 59)
	#		 | +------------- hour (0 - 23)
	#		 | | +------------- day of the month (1 - 31)
	#		 | | | +------------- month (1 - 12)
	#		 | | | | +------------- day of week (1..7); 1 is Monday
	#		 | | | | |
	#		 * * * * *		command to execute
	#
	#	crontab=(
	#		'* * * * *		every-minute-job'
	#		'*/2 * * * *	every-2-minute-job'
	#		'13 * * * *		13th-minute-of-every-hour-job'
	#		'@hourly		hourly-job'
	#		'* * * * */2	tuesday-thursday-saturday-job'
	#	)
	#
	# cron fields should be delimited by space(s) or tab(s)
	# supports @hourly, @daily, @midnight and @weekly specials
	#

	# args

	(( $# != 2 )) && { errcho 'invalid number of arguments'; return $(( exitcode_ERROR_IN_ARGUMENTS )); }
	local -r -n _crontab_array="${1-}" # by ref
	local -r -n _jobs_to_do_array="${2-}" # by ref

	# consts

	local -r -i                           M=0       H=1       d=2       m=3       u=4       CMD=5			# field order
	local -r -a cron_fields_dictionary=( [M]='%-M' [H]='%-H' [d]='%-d' [m]='%-m' [u]='%-u' [CMD]='CMD' )	# field strftime() format
	local -r asterisk_RE='^[*]/[0-9]{1,2}$'
	local -r number_RE='^[0-9]{1,2}$'
	local -r valid_crontab_line_RE='^((([*]|[0-9]{1,2})(/[0-9]{1,2})?[[:space:]]+){5}|(@hourly|@daily|@midnight|@weekly)[[:space:]]+)[^[:space:]]+'
	#                               ^(((   |          )(           )             )   |(       |      |         |       )            )

	# vars

	local -a crontab_line_splitted
	local -i start_time line_iterator field_iterator this_field_time_value
	local crontab_line_raw cmd_to_exec this_field

	# code

	start_time="$( get_current_system_time_in_seconds )"

	_jobs_to_do_array=() # reset jobs_to_do

	# for each crontab line
	for (( line_iterator=0; line_iterator < ${#_crontab_array[@]}; line_iterator++ )); do
		crontab_line_raw="${_crontab_array[line_iterator]}"

		if [[ ! "$crontab_line_raw" =~ $valid_crontab_line_RE ]]; then
			errcho "invalid crontab line '$crontab_line_raw'"
			continue
		fi

		read -r -a crontab_line_splitted <<< "$crontab_line_raw"

		# transform specials
		case "${crontab_line_splitted}" in
			'@hourly')					crontab_line_splitted=( '0' '*' '*' '*' '*' "${crontab_line_splitted[@]:$H}" );;
			'@daily' | '@midnight')		crontab_line_splitted=( '0' '0' '*' '*' '*' "${crontab_line_splitted[@]:$H}" );;
			'@weekly')					crontab_line_splitted=( '0' '0' '*' '*' '0' "${crontab_line_splitted[@]:$H}" );;
			'@monthly')					crontab_line_splitted=( '0' '0' '1' '*' '*' "${crontab_line_splitted[@]:$H}" );;
		esac

		# for each field in line
		for (( field_iterator=0; field_iterator <= CMD; field_iterator++ )); do
			if (( field_iterator == CMD )); then # add a command to array
				cmd_to_exec="${crontab_line_splitted[*]:$CMD}" # note: *, not @
				_jobs_to_do_array+=( "$cmd_to_exec" )
				break
			fi

			this_field="${crontab_line_splitted[field_iterator]}"
			this_field_time_value="$( format_date_in_seconds "$start_time" "${cron_fields_dictionary[field_iterator]}" )"

			if [[ "$this_field" =~ $asterisk_RE ]] && (( this_field_time_value % ${this_field##*/} != 0 )); then # handle * and */num
				break
			elif [[ "$this_field" =~ $number_RE ]] && (( this_field_time_value != this_field )); then # handle numbers
				break
			fi
		done
	done
}

function wait_for_next_minute {																		(( script_debug )) && debugcho

	# if seconds is 00 at the start, wait for a full minute
	while (( $( format_date_in_seconds -1 '%-S' ) % 60 == 0 )); do
		snore 0.1
	done

	while (( $( format_date_in_seconds -1 '%-S' ) % 60 != 0 )); do
		snore 0.1
	done

}

function do_cron_jobs_indefinitely {																(( script_debug )) && debugcho

	# consts

	local -r -i loop_duration_in_s=60 # for debug purposes, 60 in production

	# vars

	local -a jobs_to_do=()
	local -i time_before_execution_in_s time_after_execution_in_s execution_time_in_s job_iterator
	local job_to_execute

	# code

	while true; do
		time_before_execution_in_s="$( get_current_system_time_in_seconds )"

		if pgrep_quiet 'selfupgrade|S69hive'; then
			# do wait for Hive installation to be finished bc we don't have /hive atm and this could fire a false positive
			print_controller_log_entry 'info' "selfupgrade and/or S69hive running, skipping checks..."
			increment_checkup_counter 'selfupgrade_running' 'alarm'
		else
			# do cron work
			populate_array_with_actual_cron_jobs 'crontab' 'jobs_to_do'
			for (( job_iterator=0; job_iterator < ${#jobs_to_do[@]}; job_iterator++ )); do
				job_to_execute="${jobs_to_do[job_iterator]}"
				eval "$job_to_execute"
				if (( $? == 0 )); then
					increment_checkup_counter "$job_to_execute" 'idle'
				else
					increment_checkup_counter "$job_to_execute" 'alarm'
				fi
			done
		fi

		time_after_execution_in_s="$( get_current_system_time_in_seconds )"

		(( execution_time_in_s = time_after_execution_in_s - time_before_execution_in_s ))

		if (( execution_time_in_s > $( calculate_percent_from_number 80 "$loop_duration_in_s" ) )); then
			print_controller_log_entry 'warning' "Controller lagging: routine checkup took ${execution_time_in_s}s ( > 80% of an idle time which is ${loop_duration_in_s}s )"
			increment_checkup_counter 'controller_lagging' 'alarm'
		fi

		wait_for_next_minute
	done
}


# global consts

declare -r -i assign_tag_to_worker=1 # can be in config file
declare -r -i log_lines_to_tail=200
declare -r controller_log_file='/config/hive-controller.log'
declare -r unique_delimiter="d${RANDOM}e${RANDOM}l${RANDOM}i${RANDOM}m"

declare -r -i exitcode_OK_NOTHING_HAPPENED=0
declare -r -i exitcode_WARNING_SOMETHING_HAPPENED=1


# global sources

source asic-model || echo 'ERROR: /hive/bin/asic-model not found'
source /hive-config/rig.conf || echo 'ERROR: /hive-config/rig.conf not found' # sourced for $HIVE_HOST_URL ??? should we source it from time to time?
source colors || echo 'ERROR: /hive/bin/colors not found'
source /hive/bin/hive-functions.sh || { echo 'ERROR: /hive/bin/hive-functions.sh not found'; exit 1; }


# global exports

export PATH=$PATH:/hive/bin:/hive/sbin
export LD_LIBRARY_PATH=/hive/lib


# crontab

# shellcheck disable=SC2034
declare -r -a crontab=(
	'* * * * *		checkup:is_it_1970_year'
	'* * * * *		checkup:is_memory_full'
	'* * * * *		checkup:is_build_updated'
	'* * * * *		checkup:is_virus_found'
	'* * * * *		checkup:are_logs_updated'
	'*/5 * * * *	execute:agent_screen_dontattach'
	'@hourly		checkup:is_NAND_in_RO_mode'
	'@hourly		execute:cache_hive_ip'
	'@midnight		print_checkup_summary_report'
)


# main()

#TODO:
#watchdog alert
#pool checks
#DNS checks
#wd
# warn unsigned fw owners
# extended virus checks

parse_arguments "$@"
initialize_dictionaries
print_controller_log_entry 'info' "Controller $script_version started"

do_cron_jobs_indefinitely

# shellcheck disable=SC2154
exit $(( exitcode_ERROR_SOMETHING_WEIRD )) # you should never see that they said
